import { Marker } from './marker';
import { lexer  } from './lexer';

interface TableOfContentsEntry {
	/** toc1 - eg: The Gospel According to Matthew*/
	long_text?: string,

	/** toc2 - eg: Matthew */
	short_text?: string,

	/** toc3 - eg: Mat */
	abbreviation?: string,
};


/**
 * Represents set of data for markers which can be used in multiple
 * levels, eg, \mt1, \mt2, etc
 */
type LeveledData<T> = {
	[ index: number ] : T;
};

/**
 * Represents an error message produced by the parser
 */
type ParserError = {
	message : string,
	marker  : Marker,
};

interface StyleBlockBase {
	/**
	 * Minimum extent of the styling as expressed in "gap index" (gap 0 is before
	 * first character, gap 1 is after first character, thus a StyleBlock from 0
	 * to 1 applies to just the first character)
	 */
	min : number;

	/*
	 * Maximum extent of the styling as expressed in "gap index"
	 */
	max : number;
};

/**
 * Represents a region of text making up a single verse
 */
interface StyleBlockVerse extends StyleBlockBase{
	kind : "v";

	data : {
		verse : number,
	};
};

/**
 * Represents a region of text making up an auto-line-wrapping paragraph
 * of flowing text which may span multiple verses
 */
interface StyleBlockParagraph extends StyleBlockBase{
	kind : "p";
};

type StyleBlock = (StyleBlockVerse |
									 StyleBlockParagraph
									);

interface ParseResultBody {
	/**
	 * The full text of the parsed chapter without any styling, line breaks, etc
	 */
	text : string;

	/**
	 * Regions of styling for `text`
	 */
	styling : StyleBlock[],
};

interface ParseResultChapterSuccess {
	success : true;

	errors  : ParserError[];

	/** Chapter number, as specified by \c tag */
	chapter : number;

	/** Alternative chapter number, as specified by \ca */
	chapter_alt? : number;

	/** The name used to represent the chapter, rather than just
	 * using the book's chapter label postfixed by the number
	 * eg \cl Psalm One, rather than the autogenerated "Chapter 1"
	 * or "Psalm 1" if the book's chapter_label is set
	 */
	label?: string;

	/**
	 * Initial character to be printed larger than rest of text
	 * at the very start of the text
	 */
	drop_cap? : string;

	/**
	 * Extra text added by translators before main verse content
	 */
	description?: string;

	/**
	 * Content of this chapter
	 */
	body : ParseResultBody;
};


type ParseResultChapter = {
	success: false,
	errors : ParserError[],
} | ParseResultChapterSuccess;


interface ParseResultBookSuccess {
	success : true,

	errors  : ParserError[],

	/** The book id, as determined by \id tag */
	book_id?: string,

	/** The extra text content following the \id tag */
	id_text?: string,

	/** Encoding, as specified by the \ide tag */
	encoding?: string,

	/** Table of contents data */
	toc  : TableOfContentsEntry,

	/** Alternative table of contents data */
	toca : TableOfContentsEntry,

	/** String representing the usfm version as per the \usfm tag */
	usfm_version? : string,

	/**
	 * Running header text, usualy rendered as text at the
	 * top of each page
	 */
	running_header?: string,

	/**
	 * Represents the label to be used in place of the word "Chapter"
	 * For example, Rather than a heading of "Chapter 5", inside Psalms
	 * printed bibles often instead have a heading of "Psalms 5"
	 */
	chapter_label? : string,

	/**
	 * Major title data
	 */
	major_title : LeveledData<string>;

	/** The parse result for each chapter in the book */
	chapters: ParseResultChapter[],
};

type ParseResultBook = {
	success : false,
	errors  : ParserError[],
} | ParseResultBookSuccess;

/**
 * Parses a complete USFM file
 */
export function parse(text: string) : ParseResultBook {
	let headers = [];

	let lex_iter : IterableIterator<Marker> = lexer(text);

	let result : ParseResultBookSuccess = {
		success     : true,
		toc         : {},
		toca        : {},
		major_title : {},
		chapters    : [],
		errors      : [],
	};

	function pushError(marker : Marker, message: string){
		result.errors.push({ message, marker });
	}

	let parsing_headers = true;
	let marker_yield_val : IteratorResult<Marker>;
	let marker : Marker = { kind: '' };
	while(parsing_headers){
		marker_yield_val = lex_iter.next();
		if(marker_yield_val.done){ return result; }
		marker = marker_yield_val.value;

		switch(marker.kind){
			case 'id':
				result.book_id = marker.data;
				result.id_text = marker.text;
				break;
			case 'ide':
				result.encoding = marker.data;
				break;
			case 'toc':
				_assignTocValue(result.toc,  marker, pushError);
				break;
			case 'toca':
				_assignTocValue(result.toca, marker, pushError);
				break;
			case 'h':
				if(marker.level !== undefined){
					pushError(marker, "Skipping deprecated \h# marker");
				} else {
					result.running_header = marker.text;
				}
				break;
			case 'mt':
				_assignLeveledData(result.major_title, marker.level, marker.text);
				break;
			case 'cl':
				result.chapter_label = marker.text;
				break;
			case 'c':
				parsing_headers = false;
				break;
			default:
				pushError(marker, "Unexpected marker in book header section");
				return { success: false,
								 errors : result.errors
							 };

		} // end of switch marker.kind
	}

	//////////////////////////////
	// Read the remaining markers from lexer, splitting them into
	// an array of arrays, where each sub array is all the markers
	// for a single chapter
	let cur             : Marker[]   = [marker];
	let chapter_markers : Marker[][] = [cur];
	for(let m of lex_iter){
		if(m.kind === 'c'){
			cur = [m];
			chapter_markers.push(cur);
		} else {
			cur.push(m);
		}
	}

	//////////////////////////////
	// Actually parse the chapter's
	result.chapters = chapter_markers.map(chapterParser);

	return result;
}

function chapterParser(markers : Marker[]) : ParseResultChapter {

	if(markers[0].kind !== 'c'){
		throw new Error("First marker in chapterParser must be of kind \\c");
	}

	let result : ParseResultChapterSuccess = {
		success : true,
		errors  : [],
		chapter : parseInt(markers[0].data!),
		body    : {
			text: '',
			styling: [],
		},
	};
	markers.shift(); // remove the \c marker

	function pushError(marker: Marker, message: string){
		result.errors.push({ marker, message });
	}

	let marker : Marker | undefined;
	let m_idx = 0;
	for(let parsing_headers = true;
			m_idx < markers.length && parsing_headers;
			++m_idx
		 ){
		let marker = markers[m_idx];
		switch(marker.kind){
			case 'ca':
				result.chapter_alt = marker.text ? parseInt(marker.text) : undefined;
				break;
			case 'ca*':
				break;
			case 'cl':
				result.label = marker.text;
				break;
			case 'cp':
				result.drop_cap = marker.text;
				break;
			case 'cd':
				result.description = marker.text;
				break;
			default:
				parsing_headers = false;
				break;
		} // end of switch marker.kind
	}

	result.body = bodyParser(markers.slice(m_idx-1), pushError);

	return result;
}

function bodyParser(markers : Marker[],
										pushError : (m: Marker, e: string) => void
									 ) : ParseResultBody {

	let result : ParseResultBody = {
		text    : '',
		styling : [],
	};

	let cur_open : { [index: string] : StyleBlock } = {};

	let marker : Marker | undefined;
	while(marker = markers.shift()){
		let min = result.text.length;
		switch(marker.kind){
			case 'p':
				if(cur_open['p']){
					cur_open['p'].max = min;
					result.styling.push(cur_open['p']);
				}
				cur_open['p'] = {
					kind: 'p', min: min, max: min,
				};
				break;
			case 'v':
				result.text += marker.text;
				if(cur_open['v']){
					cur_open['v'].max = min;
					result.styling.push(cur_open['v']);
				}
				if(marker.data === undefined){
					pushError(marker, "Expected verse marker to have verse number as data");
				} else if (!marker.data.match(/\d+/)) {
					pushError(marker, "Expected verse marker's data to be integer");
				} else {
					cur_open['v'] = {
						kind: 'v', min: min, max: min,
						data: { verse: parseInt(marker.data) },
					};
				}
				break;
			default:
				console.log("WARNING - skipping unknown marker: " + marker.kind);
				break;
		}
		let max = result.text.length;
	}

	// Close all outstanding blocks implicity at end of chapter
	let max = result.text.length;
	for(let k of Object.keys(cur_open)){
		if(cur_open[k] == null){ continue; }
		cur_open[k].max = max;
		result.styling.push(cur_open[k]);
	}

	// Sort blocks
	result.styling.sort((a,b) => {
		if(a.min == b.min){ return b.max - a.max; }
		return a.min - b.min;
	});

	return result;
}


function _assignTocValue(toc    : TableOfContentsEntry,
												 marker : Marker,
												 pushError : (a: Marker, b: string) => void
												){
	switch(marker.level){
		case undefined:
		case 1:
			toc.long_text = marker.text;
			break;
		case 2:
			toc.short_text = marker.text;
			break;
		case 3:
			toc.abbreviation = marker.text;
			break;
		default:
			pushError(
				marker,
				"Invalid level for toc tag, expected 1, 2 or 3, got: " + marker.level
			);
			break;
	}
}

function _assignLeveledData<T>(ld    : LeveledData<T>,
															 level : number | undefined,
															 value : T
															){
	if(level === undefined){
		level = 1;
	}
	ld[level] = value;
}
