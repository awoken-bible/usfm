import { Marker } from './marker';
import { lexer  } from './lexer';

interface TableOfContentsEntry {
	/** toc1 - eg: The Gospel According to Matthew*/
	long_text?: string,

	/** toc2 - eg: Matthew */
	short_text?: string,

	/** toc3 - eg: Mat */
	abbreviation?: string,
};


/**
 * Represents a single node of the USFM abstract syntax tree
 */
type UsfmNode = {
	kind: string,

	/**
	 * The verse number containing this text
	 * Will be set to zero if this node represents content outside
	 * of any verse (predominantly section headings)
	 */
	verse: number,
};

/**
 * Represents set of data for markers which can be used in multiple
 * levels, eg, \mt1, \mt2, etc
 */
type LeveledData<T> = {
	[ index: number ] : T;
};

/**
 * Represents an error message produced by the parser
 */
type ParserError = {
	message : string,
	marker  : Marker,
};

interface ParseResultChapterSuccess {
	success : true;

	errors  : ParserError[];

	/** Chapter number, as specified by \c tag */
	chapter : number;

	/** Alternative chapter number, as specified by \ca */
	chapter_alt? : number;

	/** The name used to represent the chapter, rather than just
	 * using the book's chapter label postfixed by the number
	 * eg \cl Psalm One, rather than the autogenerated "Chapter 1"
	 * or "Psalm 1" if the book's chapter_label is set
	 */
	label?: string;

	/**
	 * Initial character to be printed larger than rest of text
	 * at the very start of the text
	 */
	drop_cap? : string;

	/**
	 * Extra text added by translators before main verse content
	 */
	description?: string;
};


type ParseResultChapter = {
	success: false,
	errors : ParserError[],
} | ParseResultChapterSuccess;


interface ParseResultBookSuccess {
	success : true,

	errors  : ParserError[],

	/** The book id, as determined by \id tag */
	book_id?: string,

	/** The extra text content following the \id tag */
	id_text?: string,

	/** Encoding, as specified by the \ide tag */
	encoding?: string,

	/** Table of contents data */
	toc  : TableOfContentsEntry,

	/** Alternative table of contents data */
	toca : TableOfContentsEntry,

	/** String representing the usfm version as per the \usfm tag */
	usfm_version? : string,

	/**
	 * Running header text, usualy rendered as text at the
	 * top of each page
	 */
	running_header?: string,

	/**
	 * Represents the label to be used in place of the word "Chapter"
	 * For example, Rather than a heading of "Chapter 5", inside Psalms
	 * printed bibles often instead have a heading of "Psalms 5"
	 */
	chapter_label? : string,

	/**
	 * Major title data
	 */
	major_title : LeveledData<string>;

	/** The parse result for each chapter in the book */
	chapters: ParseResultChapter[],
};

type ParseResultBook = {
	success : false,
	errors  : ParserError[],
} | ParseResultBookSuccess;

/**
 * Parses a complete USFM file
 */
export function parse(text: string) : ParseResultBook {
	let headers = [];

	let it : IterableIterator<Marker> = lexer(text);

	let result : ParseResultBookSuccess = {
		success     : true,
		toc         : {},
		toca        : {},
		major_title : {},
		chapters    : [],
		errors      : [],
	};

	function pushError(marker : Marker, message: string){
		result.errors.push({ message, marker });
	}

	let parsing_headers = true;
	let marker_yield_val : IteratorResult<Marker>;
	let marker : Marker = { kind: '' };
	while(parsing_headers){
		marker_yield_val = it.next();
		if(marker_yield_val.done){ return result; }
		marker = marker_yield_val.value;

		switch(marker.kind){
			case 'id':
				result.book_id = marker.data;
				result.id_text = marker.text;
				break;
			case 'ide':
				result.encoding = marker.data;
				break;
			case 'toc':
				_assignTocValue(result.toc,  marker, pushError);
				break;
			case 'toca':
				_assignTocValue(result.toca, marker, pushError);
				break;
			case 'h':
				if(marker.level !== undefined){
					pushError(marker, "Skipping deprecated \h# marker");
				} else {
					result.running_header = marker.text;
				}
				break;
			case 'mt':
				_assignLeveledData(result.major_title, marker.level, marker.text);
				break;
			case 'cl':
				result.chapter_label = marker.text;
				break;
			case 'c':
				parsing_headers = false;
				break;
			default:
				pushError(marker, "Unexpected marker in book header section");
				return { success: false,
								 errors : result.errors
							 };

		} // end of switch marker.kind
	}

	let chpt_parser = chapterParser(marker);
	let chpt : IteratorResult<ParseResultChapter, never>;

	while(true){
		chpt = chpt_parser.next(marker);

		marker_yield_val = it.next();
		marker = marker_yield_val.value;

		if(marker_yield_val.done || marker.kind === 'c'){
			result.chapters.push(chpt.value);
			chpt_parser = chapterParser(marker);
			if(marker_yield_val.done){ break; }
		}
	}


	return result;
}

function* chapterParser(marker : Marker) : Generator<ParseResultChapter, never, Marker> {

	if(marker.kind !== 'c'){
		throw new Error("First marker in chapterParser must be of kind \c");
	}

	let result : ParseResultChapterSuccess = {
		success : true,
		errors  : [],
		chapter : parseInt(marker.data!),
	};

	function pushError(marker: Marker, message: string){
		result.errors.push({ marker, message });
	}

	marker = (yield result)! as Marker;

	let parsing_headers = true;
	while(parsing_headers && marker){
		switch(marker.kind){
			case 'ca':
				result.chapter_alt = marker.text ? parseInt(marker.text) : undefined;
				break;
			case 'ca*':
				break;
			case 'cl':
				result.label = marker.text;
				break;
			case 'cp':
				result.drop_cap = marker.text;
				break;
			case 'cd':
				result.description = marker.text;
				break;
			default:
				parsing_headers = false;
				break;
		} // end of switch marker.kind
		marker = (yield result)! as Marker;
	}

	// now parsing chapter body
	let verse = 0;
	while(marker && marker.kind !== 'c'){
		// :TODO: impl
		yield result;
	}

	// Prevent ever returning (calling function is responsible
	// for no longer calling next() on this generator)
	while(true){ yield result; }
}

function _assignTocValue(toc    : TableOfContentsEntry,
												 marker : Marker,
												 pushError : (a: Marker, b: string) => void
												){
	switch(marker.level){
		case undefined:
		case 1:
			toc.long_text = marker.text;
			break;
		case 2:
			toc.short_text = marker.text;
			break;
		case 3:
			toc.abbreviation = marker.text;
			break;
		default:
			pushError(
				marker,
				"Invalid level for toc tag, expected 1, 2 or 3, got: " + marker.level
			);
			break;
	}
}

function _assignLeveledData<T>(ld    : LeveledData<T>,
															 level : number | undefined,
															 value : T
															){
	if(level === undefined){
		level = 1;
	}
	ld[level] = value;
}
